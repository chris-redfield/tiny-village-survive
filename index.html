<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Small Village - 3D Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            overflow: hidden;
        }

        .game-container {
            position: relative;
        }

        #gameCanvas {
            display: block;
            cursor: none;
            image-rendering: pixelated;
        }

        #minimapCanvas {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #4a90e2;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 5px;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3366;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <canvas id="minimapCanvas"></canvas>
        <div id="ui">
            <div>Village Explorer</div>
            <div id="posInfo">Position: (0, 0)</div>
            <div id="fpsInfo">FPS: 0</div>
        </div>
        <div id="crosshair">+</div>
        <div id="instructions">
            WASD/Arrows - Move | A/D - Strafe | Q/E - Look up/down | Click for mouse look
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1600;
        canvas.height = 900;

        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 250;
        minimapCanvas.height = 250;

        // World settings
        const WORLD_SIZE = 2000;
        const CELL_SIZE = 40;

        // Building definitions with heights
        const BUILDING_TYPES = {
            HOUSE: {
                name: 'House',
                wallHeight: 60,
                roofHeight: 30,
                roofType: 'peaked',
                wallColor: { r: 180, g: 140, b: 100 },
                roofColor: { r: 139, g: 69, b: 19 }
            },
            TOWER: {
                name: 'Tower',
                wallHeight: 120,
                roofHeight: 40,
                roofType: 'peaked',
                wallColor: { r: 120, g: 120, b: 130 },
                roofColor: { r: 80, g: 80, b: 90 }
            },
            BARN: {
                name: 'Barn',
                wallHeight: 50,
                roofHeight: 35,
                roofType: 'peaked',
                wallColor: { r: 160, g: 82, b: 45 },
                roofColor: { r: 100, g: 50, b: 30 }
            },
            WELL: {
                name: 'Well',
                wallHeight: 25,
                roofHeight: 15,
                roofType: 'flat',
                wallColor: { r: 100, g: 100, b: 110 },
                roofColor: { r: 80, g: 60, b: 40 }
            },
            CHURCH: {
                name: 'Church',
                wallHeight: 90,
                roofHeight: 50,
                roofType: 'peaked',
                wallColor: { r: 200, g: 200, b: 210 },
                roofColor: { r: 60, g: 60, b: 70 }
            },
            FENCE: {
                name: 'Fence',
                wallHeight: 20,
                roofHeight: 0,
                roofType: 'none',
                wallColor: { r: 139, g: 90, b: 43 },
                roofColor: { r: 0, g: 0, b: 0 }
            }
        };

        // Village buildings - expanded village
        const buildings = [
            // === MAIN VILLAGE CENTER ===
            // Central tower/watchtower
            { type: BUILDING_TYPES.TOWER, x: 950, y: 950, width: 60, depth: 60 },

            // Church near center
            { type: BUILDING_TYPES.CHURCH, x: 800, y: 850, width: 80, depth: 120 },

            // Central well
            { type: BUILDING_TYPES.WELL, x: 1050, y: 980, width: 35, depth: 35 },

            // === RESIDENTIAL DISTRICT (Northwest) ===
            { type: BUILDING_TYPES.HOUSE, x: 300, y: 300, width: 80, depth: 60 },
            { type: BUILDING_TYPES.HOUSE, x: 450, y: 280, width: 70, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 600, y: 320, width: 75, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 320, y: 450, width: 65, depth: 75 },
            { type: BUILDING_TYPES.HOUSE, x: 480, y: 420, width: 80, depth: 60 },
            { type: BUILDING_TYPES.HOUSE, x: 640, y: 480, width: 70, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 280, y: 600, width: 75, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 450, y: 580, width: 60, depth: 80 },

            // === RESIDENTIAL DISTRICT (Northeast) ===
            { type: BUILDING_TYPES.HOUSE, x: 1200, y: 300, width: 80, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 1350, y: 280, width: 70, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 1500, y: 350, width: 75, depth: 60 },
            { type: BUILDING_TYPES.HOUSE, x: 1180, y: 450, width: 65, depth: 75 },
            { type: BUILDING_TYPES.HOUSE, x: 1380, y: 420, width: 80, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 1550, y: 500, width: 70, depth: 65 },

            // === RESIDENTIAL DISTRICT (Southwest) ===
            { type: BUILDING_TYPES.HOUSE, x: 300, y: 1200, width: 75, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 480, y: 1180, width: 70, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 280, y: 1350, width: 80, depth: 60 },
            { type: BUILDING_TYPES.HOUSE, x: 450, y: 1380, width: 65, depth: 75 },
            { type: BUILDING_TYPES.HOUSE, x: 620, y: 1300, width: 70, depth: 70 },

            // === RESIDENTIAL DISTRICT (Southeast) ===
            { type: BUILDING_TYPES.HOUSE, x: 1250, y: 1200, width: 75, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 1420, y: 1250, width: 70, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 1580, y: 1180, width: 65, depth: 75 },
            { type: BUILDING_TYPES.HOUSE, x: 1300, y: 1380, width: 80, depth: 60 },
            { type: BUILDING_TYPES.HOUSE, x: 1500, y: 1400, width: 70, depth: 70 },

            // === MARKET/COMMERCIAL AREA (East of center) ===
            { type: BUILDING_TYPES.HOUSE, x: 1150, y: 800, width: 90, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 1150, y: 920, width: 85, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 1150, y: 1040, width: 80, depth: 70 },
            { type: BUILDING_TYPES.WELL, x: 1280, y: 900, width: 30, depth: 30 },
            { type: BUILDING_TYPES.WELL, x: 1280, y: 1000, width: 30, depth: 30 },

            // === FARM AREA (Far East) - with fenced enclosure ===
            { type: BUILDING_TYPES.BARN, x: 1650, y: 800, width: 120, depth: 80 },
            { type: BUILDING_TYPES.BARN, x: 1650, y: 950, width: 100, depth: 70 },
            { type: BUILDING_TYPES.HOUSE, x: 1800, y: 780, width: 70, depth: 60 }, // Farmhouse

            // Farm fencing (partial enclosure)
            { type: BUILDING_TYPES.FENCE, x: 1600, y: 750, width: 300, depth: 8 },  // North fence
            { type: BUILDING_TYPES.FENCE, x: 1600, y: 750, width: 8, depth: 320 },  // West fence
            { type: BUILDING_TYPES.FENCE, x: 1600, y: 1062, width: 300, depth: 8 }, // South fence
            { type: BUILDING_TYPES.FENCE, x: 1892, y: 750, width: 8, depth: 320 },  // East fence

            // === SECOND FARM (Far South) ===
            { type: BUILDING_TYPES.BARN, x: 850, y: 1550, width: 110, depth: 75 },
            { type: BUILDING_TYPES.BARN, x: 1000, y: 1580, width: 90, depth: 65 },
            { type: BUILDING_TYPES.HOUSE, x: 950, y: 1450, width: 65, depth: 60 }, // Farmhouse

            // Small animal pen fencing
            { type: BUILDING_TYPES.FENCE, x: 1100, y: 1520, width: 120, depth: 8 },
            { type: BUILDING_TYPES.FENCE, x: 1100, y: 1520, width: 8, depth: 150 },
            { type: BUILDING_TYPES.FENCE, x: 1100, y: 1662, width: 120, depth: 8 },
            { type: BUILDING_TYPES.FENCE, x: 1212, y: 1520, width: 8, depth: 150 },

            // === OUTPOST/WATCHTOWERS ===
            { type: BUILDING_TYPES.TOWER, x: 200, y: 200, width: 50, depth: 50 },   // Northwest
            { type: BUILDING_TYPES.TOWER, x: 1750, y: 200, width: 50, depth: 50 },  // Northeast
            { type: BUILDING_TYPES.TOWER, x: 200, y: 1750, width: 50, depth: 50 },  // Southwest
            { type: BUILDING_TYPES.TOWER, x: 1750, y: 1750, width: 50, depth: 50 }, // Southeast

            // === ADDITIONAL WELLS scattered around ===
            { type: BUILDING_TYPES.WELL, x: 550, y: 350, width: 28, depth: 28 },
            { type: BUILDING_TYPES.WELL, x: 1400, y: 550, width: 28, depth: 28 },
            { type: BUILDING_TYPES.WELL, x: 400, y: 1280, width: 28, depth: 28 },
            { type: BUILDING_TYPES.WELL, x: 1450, y: 1320, width: 28, depth: 28 },

            // === SMALL GARDEN with fence (near center-west) ===
            { type: BUILDING_TYPES.FENCE, x: 650, y: 850, width: 100, depth: 8 },
            { type: BUILDING_TYPES.FENCE, x: 650, y: 850, width: 8, depth: 100 },
            { type: BUILDING_TYPES.FENCE, x: 650, y: 942, width: 100, depth: 8 },
            { type: BUILDING_TYPES.FENCE, x: 742, y: 850, width: 8, depth: 100 },

            // === ADDITIONAL CHURCHES/CHAPELS ===
            { type: BUILDING_TYPES.CHURCH, x: 1400, y: 700, width: 70, depth: 100 },

            // === STORAGE BUILDINGS ===
            { type: BUILDING_TYPES.BARN, x: 580, y: 700, width: 60, depth: 50 },
            { type: BUILDING_TYPES.BARN, x: 1350, y: 1100, width: 70, depth: 55 },
        ];

        // Player
        const player = {
            x: 1000,
            y: 700,
            z: 30, // Eye height
            angle: Math.PI / 2,
            pitch: 0,
            moveSpeed: 4,
            fov: Math.PI / 3,
            rayCount: 400
        };

        // Input state
        const keys = {};
        let pointerLocked = false;

        // Textures
        function createBrickTexture(baseColor) {
            const texCanvas = document.createElement('canvas');
            texCanvas.width = 32;
            texCanvas.height = 32;
            const texCtx = texCanvas.getContext('2d');

            // Base color
            texCtx.fillStyle = `rgb(${baseColor.r}, ${baseColor.g}, ${baseColor.b})`;
            texCtx.fillRect(0, 0, 32, 32);

            // Brick pattern
            texCtx.strokeStyle = `rgb(${baseColor.r * 0.7}, ${baseColor.g * 0.7}, ${baseColor.b * 0.7})`;
            texCtx.lineWidth = 1;

            // Horizontal lines
            for (let y = 0; y < 32; y += 8) {
                texCtx.beginPath();
                texCtx.moveTo(0, y);
                texCtx.lineTo(32, y);
                texCtx.stroke();
            }

            // Vertical lines (offset every other row)
            for (let row = 0; row < 4; row++) {
                const offset = row % 2 === 0 ? 0 : 8;
                for (let x = offset; x < 32; x += 16) {
                    texCtx.beginPath();
                    texCtx.moveTo(x, row * 8);
                    texCtx.lineTo(x, (row + 1) * 8);
                    texCtx.stroke();
                }
            }

            // Add some variation
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 32;
                const y = Math.random() * 32;
                const variation = (Math.random() - 0.5) * 30;
                texCtx.fillStyle = `rgba(${baseColor.r + variation}, ${baseColor.g + variation}, ${baseColor.b + variation}, 0.3)`;
                texCtx.fillRect(x, y, 2, 2);
            }

            return texCtx.getImageData(0, 0, 32, 32);
        }

        function createRoofTexture(baseColor) {
            const texCanvas = document.createElement('canvas');
            texCanvas.width = 32;
            texCanvas.height = 32;
            const texCtx = texCanvas.getContext('2d');

            // Base color
            texCtx.fillStyle = `rgb(${baseColor.r}, ${baseColor.g}, ${baseColor.b})`;
            texCtx.fillRect(0, 0, 32, 32);

            // Shingle pattern
            for (let row = 0; row < 8; row++) {
                const offset = row % 2 === 0 ? 0 : 4;
                for (let x = offset; x < 32; x += 8) {
                    const variation = (Math.random() - 0.5) * 20;
                    texCtx.fillStyle = `rgb(${baseColor.r + variation}, ${baseColor.g + variation}, ${baseColor.b + variation})`;
                    texCtx.fillRect(x, row * 4, 7, 3);

                    // Shadow line
                    texCtx.fillStyle = `rgba(0, 0, 0, 0.2)`;
                    texCtx.fillRect(x, row * 4 + 3, 8, 1);
                }
            }

            return texCtx.getImageData(0, 0, 32, 32);
        }

        // Pre-generate textures for each building type
        const wallTextures = {};
        const roofTextures = {};
        for (const [key, type] of Object.entries(BUILDING_TYPES)) {
            wallTextures[key] = createBrickTexture(type.wallColor);
            roofTextures[key] = createRoofTexture(type.roofColor);
        }

        // Sky texture
        let skyTexture = null;
        const skyImg = new Image();
        skyImg.onload = () => {
            // Create a canvas with original + horizontally flipped version for seamless wrapping
            const canvas = document.createElement('canvas');
            canvas.width = skyImg.width * 2;
            canvas.height = skyImg.height;
            const ctx = canvas.getContext('2d');

            // Draw original image on the left
            ctx.drawImage(skyImg, 0, 0);

            // Draw horizontally flipped image on the right
            ctx.save();
            ctx.translate(skyImg.width * 2, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(skyImg, 0, 0);
            ctx.restore();

            skyTexture = canvas;
            console.log('Sky texture loaded:', skyTexture.width, 'x', skyTexture.height);
        };
        skyImg.src = 'assets/night_sky_2.png';

        // Ground texture
        const groundTexture = (() => {
            const texCanvas = document.createElement('canvas');
            texCanvas.width = 32;
            texCanvas.height = 32;
            const texCtx = texCanvas.getContext('2d');

            // Grass base
            texCtx.fillStyle = '#4a7c3f';
            texCtx.fillRect(0, 0, 32, 32);

            // Grass variation
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 32;
                const y = Math.random() * 32;
                const green = 60 + Math.random() * 60;
                texCtx.fillStyle = `rgb(${40 + Math.random() * 30}, ${green}, ${30 + Math.random() * 20})`;
                texCtx.fillRect(x, y, 1, 2);
            }

            return texCtx.getImageData(0, 0, 32, 32);
        })();

        // Sky gradient colors (fallback for when texture not loaded)
        const skyColors = {
            top: { r: 10, g: 10, b: 30 },
            bottom: { r: 30, g: 30, b: 60 }
        };

        // Villager texture
        let villagerTexture = null;
        const villagerImg = new Image();
        villagerImg.crossOrigin = 'anonymous';
        villagerImg.src = 'assets/worker.png';

        villagerImg.onload = () => {
            const canvas = document.createElement('canvas');
            canvas.width = villagerImg.width;
            canvas.height = villagerImg.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(villagerImg, 0, 0);

            villagerTexture = {
                width: villagerImg.width,
                height: villagerImg.height,
                imageData: ctx.getImageData(0, 0, villagerImg.width, villagerImg.height),
                canvas: canvas
            };
            console.log('Villager texture loaded:', villagerTexture.width, 'x', villagerTexture.height);
        };

        // Villager class - moves around the village
        class Villager {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.speed = 0.8 + Math.random() * 0.4;
                this.changeDirectionTimer = 0;
                this.changeInterval = 60 + Math.random() * 120;
            }

            update() {
                this.changeDirectionTimer++;
                if (this.changeDirectionTimer > this.changeInterval) {
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.changeDirectionTimer = 0;
                    this.changeInterval = 60 + Math.random() * 120;
                }

                const newX = this.x + this.vx * this.speed;
                const newY = this.y + this.vy * this.speed;

                // Check world boundaries
                const margin = 30;
                if (newX < margin || newX > WORLD_SIZE - margin) {
                    this.vx *= -1;
                }
                if (newY < margin || newY > WORLD_SIZE - margin) {
                    this.vy *= -1;
                }

                // Check building collisions
                const villagerRadius = 15;
                let canMove = true;

                for (const building of buildings) {
                    const left = building.x - villagerRadius;
                    const right = building.x + building.width + villagerRadius;
                    const top = building.y - villagerRadius;
                    const bottom = building.y + building.depth + villagerRadius;

                    if (newX > left && newX < right && newY > top && newY < bottom) {
                        canMove = false;
                        // Reverse direction when hitting a building
                        this.vx *= -1;
                        this.vy *= -1;
                        break;
                    }
                }

                if (canMove) {
                    this.x = Math.max(margin, Math.min(WORLD_SIZE - margin, newX));
                    this.y = Math.max(margin, Math.min(WORLD_SIZE - margin, newY));
                }
            }
        }

        // Sprite class for rendering villagers in 3D
        class Sprite {
            constructor(villager, texture, width = 30, height = 45) {
                this.villager = villager;
                this.texture = texture;
                this.width = width;
                this.height = height;
                this.pixelData = { r: 0, g: 0, b: 0, a: 0 };
            }

            get x() { return this.villager.x; }
            get y() { return this.villager.y; }

            getScreenPosition() {
                const dx = this.x - player.x;
                const dy = this.y - player.y;

                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);

                let relativeAngle = angle - player.angle;

                while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
                while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;

                return { dx, dy, dist, angle, relativeAngle };
            }

            isVisible() {
                const pos = this.getScreenPosition();
                const fovHalf = player.fov / 2;

                if (Math.abs(pos.relativeAngle) > fovHalf + 0.2) {
                    return false;
                }

                if (pos.dist < 10 || pos.dist > 1500) {
                    return false;
                }

                return true;
            }

            render(ctx, canvas, wallDistances) {
                if (!this.texture || !this.isVisible()) {
                    return;
                }

                const pos = this.getScreenPosition();
                const correctedDist = pos.dist * Math.cos(pos.relativeAngle);

                if (correctedDist <= 0) return;

                const fovHalf = player.fov / 2;
                const pitchOffset = player.pitch * 300;

                // Calculate sprite size based on distance
                const spriteScale = 600 / correctedDist;
                const spriteHeight = this.height * spriteScale;
                const spriteWidth = this.width * spriteScale;

                // Calculate screen position
                const screenCenterX = (canvas.width / 2) +
                    (pos.relativeAngle / fovHalf) * (canvas.width / 2);

                // Sprite bottom at ground level, sprite stands on ground
                const horizon = canvas.height / 2 + pitchOffset;
                const groundY = horizon + (player.z - 0) * spriteScale;
                const spriteTop = groundY - spriteHeight;
                const spriteBottom = groundY;

                const spriteLeft = screenCenterX - spriteWidth / 2;
                const spriteRight = screenCenterX + spriteWidth / 2;

                if (spriteRight < 0 || spriteLeft > canvas.width) {
                    return;
                }

                // Clamp to screen bounds
                const clampedLeft = Math.max(0, Math.floor(spriteLeft));
                const clampedRight = Math.min(canvas.width, Math.ceil(spriteRight));
                const clampedTop = Math.max(0, Math.floor(spriteTop));
                const clampedBottom = Math.min(canvas.height, Math.ceil(spriteBottom));

                // Sample rate optimization - limit to ~64 samples per dimension (balance between quality and performance)
                const sampleRateY = Math.max(1, Math.floor((clampedBottom - clampedTop) / 64));
                const sampleRateX = Math.max(1, Math.floor((clampedRight - clampedLeft) / 64));

                // Calculate brightness based on distance
                const brightness = Math.max(0.3, 1 - correctedDist / 800);

                // Render sprite with sampling optimization
                for (let screenX = clampedLeft; screenX < clampedRight; screenX += sampleRateX) {
                    // Check if this column is occluded by a wall
                    const rayIndex = Math.floor((screenX / canvas.width) * player.rayCount);
                    const wallDist = wallDistances[rayIndex] || Infinity;

                    if (wallDist < correctedDist) {
                        continue; // Wall is closer, skip this column
                    }

                    const spriteX = (screenX - spriteLeft) / spriteWidth;
                    const texX = Math.floor(spriteX * this.texture.width);

                    for (let screenY = clampedTop; screenY < clampedBottom; screenY += sampleRateY) {
                        const spriteY = (screenY - spriteTop) / spriteHeight;
                        const texY = Math.floor(spriteY * this.texture.height);

                        this.getTexturePixel(texX, texY);

                        if (this.pixelData.a > 128) {
                            ctx.fillStyle = `rgba(${Math.floor(this.pixelData.r * brightness)}, ${Math.floor(this.pixelData.g * brightness)}, ${Math.floor(this.pixelData.b * brightness)}, ${this.pixelData.a / 255})`;
                            ctx.fillRect(screenX, screenY, sampleRateX, sampleRateY);
                        }
                    }
                }
            }

            getTexturePixel(x, y) {
                x = Math.max(0, Math.min(x, this.texture.width - 1));
                y = Math.max(0, Math.min(y, this.texture.height - 1));

                const imageData = this.texture.imageData;
                const index = (Math.floor(y) * this.texture.width + Math.floor(x)) * 4;

                this.pixelData.r = imageData.data[index];
                this.pixelData.g = imageData.data[index + 1];
                this.pixelData.b = imageData.data[index + 2];
                this.pixelData.a = imageData.data[index + 3];
            }
        }

        // Create villagers at valid positions
        const villagers = [];
        const sprites = [];

        function isValidVillagerPosition(x, y) {
            const margin = 30;
            if (x < margin || x > WORLD_SIZE - margin || y < margin || y > WORLD_SIZE - margin) {
                return false;
            }

            const villagerRadius = 20;
            for (const building of buildings) {
                const left = building.x - villagerRadius;
                const right = building.x + building.width + villagerRadius;
                const top = building.y - villagerRadius;
                const bottom = building.y + building.depth + villagerRadius;

                if (x > left && x < right && y > top && y < bottom) {
                    return false;
                }
            }
            return true;
        }

        function createVillagers(count) {
            for (let i = 0; i < count; i++) {
                let x, y;
                let attempts = 0;
                do {
                    x = 100 + Math.random() * (WORLD_SIZE - 200);
                    y = 100 + Math.random() * (WORLD_SIZE - 200);
                    attempts++;
                } while (!isValidVillagerPosition(x, y) && attempts < 100);

                if (attempts < 100) {
                    const villager = new Villager(x, y);
                    villagers.push(villager);
                    // Pre-create sprite for this villager (texture assigned later when loaded)
                    sprites.push(new Sprite(villager, null, 30, 45));
                }
            }
        }

        // Create 20 villagers
        createVillagers(20);

        // Assign texture to sprites once loaded
        villagerImg.addEventListener('load', () => {
            for (const sprite of sprites) {
                sprite.texture = villagerTexture;
            }
        });

        // Off-screen canvas for compositing (reused each frame)
        const offCanvas = document.createElement('canvas');
        offCanvas.width = canvas.width;
        offCanvas.height = canvas.height;
        const offCtx = offCanvas.getContext('2d');

        // Check if point is inside a building
        function pointInBuilding(x, y) {
            for (const building of buildings) {
                if (x >= building.x && x < building.x + building.width &&
                    y >= building.y && y < building.y + building.depth) {
                    return building;
                }
            }
            return null;
        }

        // Ray-building intersection
        function rayBuildingIntersection(rayX, rayY, rayDirX, rayDirY, building) {
            const hits = [];

            // Check all 4 walls
            const walls = [
                { x1: building.x, y1: building.y, x2: building.x + building.width, y2: building.y, side: 'front' },
                { x1: building.x + building.width, y1: building.y, x2: building.x + building.width, y2: building.y + building.depth, side: 'right' },
                { x1: building.x, y1: building.y + building.depth, x2: building.x + building.width, y2: building.y + building.depth, side: 'back' },
                { x1: building.x, y1: building.y, x2: building.x, y2: building.y + building.depth, side: 'left' }
            ];

            for (const wall of walls) {
                const hit = rayLineIntersection(rayX, rayY, rayDirX, rayDirY, wall.x1, wall.y1, wall.x2, wall.y2);
                if (hit) {
                    hit.building = building;
                    hit.side = wall.side;
                    hit.wallLength = Math.sqrt((wall.x2 - wall.x1) ** 2 + (wall.y2 - wall.y1) ** 2);

                    // Calculate texture coordinate along wall
                    if (wall.x1 === wall.x2) {
                        hit.texCoord = (hit.y - wall.y1) / (wall.y2 - wall.y1);
                    } else {
                        hit.texCoord = (hit.x - wall.x1) / (wall.x2 - wall.x1);
                    }

                    hits.push(hit);
                }
            }

            return hits;
        }

        // Ray-line segment intersection
        function rayLineIntersection(rayX, rayY, rayDirX, rayDirY, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;

            const denom = rayDirX * dy - rayDirY * dx;
            if (Math.abs(denom) < 0.0001) return null;

            const t = ((x1 - rayX) * dy - (y1 - rayY) * dx) / denom;
            const u = ((x1 - rayX) * rayDirY - (y1 - rayY) * rayDirX) / denom;

            if (t > 0.1 && u >= 0 && u <= 1) {
                return {
                    x: rayX + rayDirX * t,
                    y: rayY + rayDirY * t,
                    dist: t
                };
            }

            return null;
        }

        // Cast a single ray and get all hits sorted by distance
        function castRay(angle) {
            const dirX = Math.cos(angle);
            const dirY = Math.sin(angle);

            const hits = [];

            // Check intersections with all buildings
            for (const building of buildings) {
                const buildingHits = rayBuildingIntersection(player.x, player.y, dirX, dirY, building);
                hits.push(...buildingHits);
            }

            // Check world boundaries
            // North wall has an opening from x=900 to x=1100 to see the sky
            const boundaries = [
                { x1: 0, y1: 0, x2: 900, y2: 0, type: 'boundary' },      // North wall left segment
                { x1: 1100, y1: 0, x2: WORLD_SIZE, y2: 0, type: 'boundary' }, // North wall right segment
                { x1: WORLD_SIZE, y1: 0, x2: WORLD_SIZE, y2: WORLD_SIZE, type: 'boundary' },
                { x1: 0, y1: WORLD_SIZE, x2: WORLD_SIZE, y2: WORLD_SIZE, type: 'boundary' },
                { x1: 0, y1: 0, x2: 0, y2: WORLD_SIZE, type: 'boundary' }
            ];

            for (const bound of boundaries) {
                const hit = rayLineIntersection(player.x, player.y, dirX, dirY, bound.x1, bound.y1, bound.x2, bound.y2);
                if (hit) {
                    hit.isBoundary = true;
                    hit.building = {
                        type: {
                            wallHeight: 100,
                            roofHeight: 0,
                            roofType: 'none',
                            wallColor: { r: 60, g: 60, b: 70 }
                        }
                    };
                    hits.push(hit);
                }
            }

            // Sort by distance
            hits.sort((a, b) => a.dist - b.dist);

            return hits;
        }

        // Draw sky with texture
        function drawSky() {
            const pitchOffset = player.pitch * 300;
            const horizonY = canvas.height / 2 + pitchOffset;

            if (skyTexture) {
                const width = skyTexture.width;
                const height = skyTexture.height;

                let angleRatio = player.angle / (2 * Math.PI);
                let xOffset = (angleRatio * width) % width;
                if (xOffset < 0) xOffset += width;

                // Fill entire sky area with dark color first
                ctx.fillStyle = '#0a0a1a';
                ctx.fillRect(0, 0, canvas.width, Math.max(0, horizonY));

                // Use larger sky height to reduce empty space
                const fixedSkyHeight = canvas.height * 0.95;
                const skyHeight = Math.max(0, Math.min(fixedSkyHeight, horizonY));

                if (skyHeight > 0) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(0, 0, canvas.width, skyHeight);
                    ctx.clip();

                    // Draw sky with seamless wrapping
                    ctx.drawImage(skyTexture,
                        xOffset, 0, width - xOffset, height,
                        0, 0, canvas.width * (1 - xOffset/width), fixedSkyHeight
                    );

                    if (xOffset > 0) {
                        ctx.drawImage(skyTexture,
                            0, 0, xOffset, height,
                            canvas.width * (1 - xOffset/width), 0, canvas.width * (xOffset/width), fixedSkyHeight
                        );
                    }

                    ctx.restore();
                }
            } else {
                // Fallback gradient sky
                const gradient = ctx.createLinearGradient(0, 0, 0, horizonY);
                gradient.addColorStop(0, `rgb(${skyColors.top.r}, ${skyColors.top.g}, ${skyColors.top.b})`);
                gradient.addColorStop(1, `rgb(${skyColors.bottom.r}, ${skyColors.bottom.g}, ${skyColors.bottom.b})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, Math.max(0, horizonY));
            }
        }

        // Wall distances array for sprite occlusion
        const wallDistances = new Array(player.rayCount).fill(Infinity);

        // Render the scene
        function render() {
            const pitchOffset = player.pitch * 300;
            const horizon = canvas.height / 2 + pitchOffset;

            // Reset wall distances
            wallDistances.fill(Infinity);

            // Draw sky first using canvas API (more efficient)
            drawSky();

            // Create image data for walls and ground
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            // Make image data transparent initially so sky shows through
            for (let i = 3; i < data.length; i += 4) {
                data[i] = 0; // Alpha = 0 (transparent)
            }

            // For each column (ray)
            for (let col = 0; col < player.rayCount; col++) {
                const rayAngle = player.angle - player.fov / 2 + (player.fov * col / player.rayCount);
                const hits = castRay(rayAngle);

                const stripWidth = Math.ceil(canvas.width / player.rayCount);
                const screenX = col * stripWidth;

                // Track which screen pixels are already filled (for proper occlusion)
                const columnFilled = new Array(canvas.height).fill(false);

                // Process hits from near to far - skip pixels already filled by closer objects
                for (let hitIdx = 0; hitIdx < hits.length; hitIdx++) {
                    const hit = hits[hitIdx];
                    const correctedDist = hit.dist * Math.cos(rayAngle - player.angle);

                    if (correctedDist <= 0) continue;

                    // Store closest wall distance for sprite occlusion
                    if (hitIdx === 0) {
                        wallDistances[col] = correctedDist;
                    }

                    const building = hit.building;
                    const type = building.type;

                    // Calculate wall projection
                    const wallHeight = type.wallHeight;
                    const roofHeight = type.roofHeight;
                    const totalHeight = wallHeight + roofHeight;

                    // Project heights to screen
                    const projScale = 600 / correctedDist;

                    // Wall bottom is at ground level (z=0)
                    // Wall top is at wallHeight
                    // Roof top is at wallHeight + roofHeight

                    const wallBottomScreen = horizon + (player.z - 0) * projScale;
                    const wallTopScreen = horizon + (player.z - wallHeight) * projScale;
                    const roofTopScreen = horizon + (player.z - totalHeight) * projScale;

                    // Calculate brightness based on distance and wall side
                    let brightness = Math.max(0.25, 1 - correctedDist / 1200);
                    if (hit.side === 'left' || hit.side === 'right') {
                        brightness *= 0.8; // Side walls are darker
                    }

                    // Get texture key for this building type
                    let textureKey = 'HOUSE';
                    for (const [key, t] of Object.entries(BUILDING_TYPES)) {
                        if (t === type) {
                            textureKey = key;
                            break;
                        }
                    }

                    const wallTex = wallTextures[textureKey] || wallTextures['HOUSE'];
                    const roofTex = roofTextures[textureKey] || roofTextures['HOUSE'];

                    // Draw wall
                    const wallStartY = Math.max(0, Math.floor(wallTopScreen));
                    const wallEndY = Math.min(canvas.height, Math.ceil(wallBottomScreen));

                    for (let y = wallStartY; y < wallEndY; y++) {
                        if (columnFilled[y]) continue;

                        const wallProgress = (y - wallTopScreen) / (wallBottomScreen - wallTopScreen);
                        const texY = Math.floor(wallProgress * 32) % 32;
                        const texX = Math.floor((hit.texCoord || 0) * 32 * 4) % 32;

                        const texIdx = (texY * 32 + texX) * 4;
                        const r = wallTex.data[texIdx] * brightness;
                        const g = wallTex.data[texIdx + 1] * brightness;
                        const b = wallTex.data[texIdx + 2] * brightness;

                        for (let sx = 0; sx < stripWidth && screenX + sx < canvas.width; sx++) {
                            const idx = ((y * canvas.width) + screenX + sx) * 4;
                            data[idx] = r;
                            data[idx + 1] = g;
                            data[idx + 2] = b;
                            data[idx + 3] = 255;
                        }

                        columnFilled[y] = true;
                    }

                    // Draw roof (if has roof)
                    if (type.roofType !== 'none' && roofHeight > 0) {
                        const roofStartY = Math.max(0, Math.floor(roofTopScreen));
                        const roofEndY = Math.min(canvas.height, Math.ceil(wallTopScreen));

                        for (let y = roofStartY; y < roofEndY; y++) {
                            if (columnFilled[y]) continue;

                            const roofProgress = (y - roofTopScreen) / (wallTopScreen - roofTopScreen);
                            const texY = Math.floor(roofProgress * 32) % 32;
                            const texX = Math.floor((hit.texCoord || 0) * 32 * 4) % 32;

                            const texIdx = (texY * 32 + texX) * 4;

                            // Peaked roof gets lighter at top
                            let roofBrightness = brightness;
                            if (type.roofType === 'peaked') {
                                roofBrightness *= 0.8 + 0.4 * (1 - roofProgress);
                            }

                            const r = roofTex.data[texIdx] * roofBrightness;
                            const g = roofTex.data[texIdx + 1] * roofBrightness;
                            const b = roofTex.data[texIdx + 2] * roofBrightness;

                            for (let sx = 0; sx < stripWidth && screenX + sx < canvas.width; sx++) {
                                const idx = ((y * canvas.width) + screenX + sx) * 4;
                                data[idx] = r;
                                data[idx + 1] = g;
                                data[idx + 2] = b;
                                data[idx + 3] = 255;
                            }

                            columnFilled[y] = true;
                        }
                    }
                }

                // Draw ground for unfilled pixels below horizon
                for (let y = Math.floor(horizon); y < canvas.height; y++) {
                    if (columnFilled[y]) continue;

                    // Calculate ground distance for this pixel
                    const screenDist = y - horizon;
                    if (screenDist <= 0) continue;

                    const groundDist = (player.z * 600) / screenDist;
                    const groundX = player.x + Math.cos(rayAngle) * groundDist;
                    const groundY = player.y + Math.sin(rayAngle) * groundDist;

                    // Sample ground texture
                    const texX = Math.floor(Math.abs(groundX) / 4) % 32;
                    const texY = Math.floor(Math.abs(groundY) / 4) % 32;
                    const texIdx = (texY * 32 + texX) * 4;

                    const brightness = Math.max(0.25, 1 - groundDist / 800);
                    const r = groundTexture.data[texIdx] * brightness;
                    const g = groundTexture.data[texIdx + 1] * brightness;
                    const b = groundTexture.data[texIdx + 2] * brightness;

                    for (let sx = 0; sx < stripWidth && screenX + sx < canvas.width; sx++) {
                        const idx = ((y * canvas.width) + screenX + sx) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;
                    }
                }
            }

            // Put walls/ground on off-screen canvas and composite with sky
            offCtx.putImageData(imageData, 0, 0);
            ctx.drawImage(offCanvas, 0, 0);

            // Render villager sprites (sorted by distance, far to near)
            if (villagerTexture && sprites.length > 0) {
                // Sort sprites by distance (far to near) for proper rendering order
                sprites.sort((a, b) => {
                    const distA = (a.x - player.x) ** 2 + (a.y - player.y) ** 2;
                    const distB = (b.x - player.x) ** 2 + (b.y - player.y) ** 2;
                    return distB - distA;
                });

                for (const sprite of sprites) {
                    sprite.render(ctx, canvas, wallDistances);
                }
            }
        }

        // Draw minimap
        function drawMinimap() {
            const mapSize = minimapCanvas.width;

            minimapCtx.fillStyle = '#1a1a2e';
            minimapCtx.fillRect(0, 0, mapSize, mapSize);

            const scale = mapSize / WORLD_SIZE;

            // Draw ground
            minimapCtx.fillStyle = '#4a7c3f';
            minimapCtx.fillRect(0, 0, mapSize, mapSize);

            // Draw buildings
            for (const building of buildings) {
                const type = building.type;
                minimapCtx.fillStyle = `rgb(${type.wallColor.r}, ${type.wallColor.g}, ${type.wallColor.b})`;
                minimapCtx.fillRect(
                    building.x * scale,
                    building.y * scale,
                    building.width * scale,
                    building.depth * scale
                );

                minimapCtx.strokeStyle = '#333';
                minimapCtx.lineWidth = 1;
                minimapCtx.strokeRect(
                    building.x * scale,
                    building.y * scale,
                    building.width * scale,
                    building.depth * scale
                );
            }

            // Draw villagers on minimap
            minimapCtx.fillStyle = '#ffcc00';
            for (const villager of villagers) {
                minimapCtx.beginPath();
                minimapCtx.arc(villager.x * scale, villager.y * scale, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            }

            // Draw player
            minimapCtx.fillStyle = '#ff3366';
            minimapCtx.beginPath();
            minimapCtx.arc(player.x * scale, player.y * scale, 4, 0, Math.PI * 2);
            minimapCtx.fill();

            // Draw view direction
            minimapCtx.strokeStyle = '#ff3366';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * scale, player.y * scale);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.angle) * 80) * scale,
                (player.y + Math.sin(player.angle) * 80) * scale
            );
            minimapCtx.stroke();

            // Draw FOV cone
            minimapCtx.strokeStyle = 'rgba(255, 51, 102, 0.3)';
            minimapCtx.lineWidth = 1;
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * scale, player.y * scale);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.angle - player.fov / 2) * 150) * scale,
                (player.y + Math.sin(player.angle - player.fov / 2) * 150) * scale
            );
            minimapCtx.stroke();
            minimapCtx.beginPath();
            minimapCtx.moveTo(player.x * scale, player.y * scale);
            minimapCtx.lineTo(
                (player.x + Math.cos(player.angle + player.fov / 2) * 150) * scale,
                (player.y + Math.sin(player.angle + player.fov / 2) * 150) * scale
            );
            minimapCtx.stroke();
        }

        // Player movement with collision
        function movePlayer(dx, dy) {
            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check world bounds
            const margin = 10;
            if (newX < margin || newX > WORLD_SIZE - margin || newY < margin || newY > WORLD_SIZE - margin) {
                return;
            }

            // Check building collision
            const playerRadius = 8;
            for (const building of buildings) {
                // Expanded bounds for collision
                const left = building.x - playerRadius;
                const right = building.x + building.width + playerRadius;
                const top = building.y - playerRadius;
                const bottom = building.y + building.depth + playerRadius;

                if (newX > left && newX < right && newY > top && newY < bottom) {
                    // Try sliding along walls
                    const testX = player.x + dx;
                    const testY = player.y + dy;

                    // Check if only X movement collides
                    if (!(testX > left && testX < right && player.y > top && player.y < bottom)) {
                        player.x = testX;
                    }
                    // Check if only Y movement collides
                    if (!(player.x > left && player.x < right && testY > top && testY < bottom)) {
                        player.y = testY;
                    }
                    return;
                }
            }

            player.x = newX;
            player.y = newY;
        }

        // Game loop
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        let lastFpsUpdate = performance.now();

        function gameLoop() {
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            const deltaMultiplier = deltaTime / (1000 / 60);

            // FPS counter
            frameCount++;
            if (currentTime - lastFpsUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = currentTime;
            }

            // Handle input - movement always works, mouse look requires pointer lock
            const moveX = Math.cos(player.angle) * player.moveSpeed * deltaMultiplier;
            const moveY = Math.sin(player.angle) * player.moveSpeed * deltaMultiplier;
            const strafeX = Math.cos(player.angle + Math.PI / 2) * player.moveSpeed * deltaMultiplier;
            const strafeY = Math.sin(player.angle + Math.PI / 2) * player.moveSpeed * deltaMultiplier;

            if (keys['w'] || keys['arrowup']) movePlayer(moveX, moveY);
            if (keys['s'] || keys['arrowdown']) movePlayer(-moveX, -moveY);
            if (keys['a']) movePlayer(-strafeX, -strafeY);
            if (keys['d']) movePlayer(strafeX, strafeY);

            // Arrow keys for turning (when not using mouse)
            if (keys['arrowleft']) player.angle -= 0.04 * deltaMultiplier;
            if (keys['arrowright']) player.angle += 0.04 * deltaMultiplier;

            // Q/E for looking up/down
            if (keys['q']) player.pitch = Math.min(0.8, player.pitch + 0.02 * deltaMultiplier);
            if (keys['e']) player.pitch = Math.max(-0.8, player.pitch - 0.02 * deltaMultiplier);

            // Update villagers
            for (const villager of villagers) {
                villager.update();
            }

            // Render
            render();
            drawMinimap();

            // Update UI
            document.getElementById('posInfo').textContent = `Position: (${Math.floor(player.x)}, ${Math.floor(player.y)})`;
            document.getElementById('fpsInfo').textContent = `FPS: ${fps}`;

            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === canvas;
        });

        document.addEventListener('mousemove', e => {
            if (pointerLocked) {
                player.angle += e.movementX * 0.002;
                player.pitch -= e.movementY * 0.002;

                const maxPitch = 0.8;
                player.pitch = Math.max(-maxPitch, Math.min(maxPitch, player.pitch));
            }
        });

        // Start game
        gameLoop();
    </script>
</body>
</html>
