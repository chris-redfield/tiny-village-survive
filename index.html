<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiny Village + Night Defense</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a2e;
            display: flex;
            height: 100vh;
            color: #2c1810;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .game-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #dayContainer {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #nightContainer {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 100;
        }

        #gameCanvas {
            flex: 1;
            background: linear-gradient(180deg, #87ceeb 0%, #90ee90 100%);
            cursor: crosshair;
            display: block;
        }

        #nightCanvas {
            display: block;
            cursor: none;
            image-rendering: pixelated;
        }

        #minimapCanvas {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #4a90e2;
            background: #000;
            border-radius: 5px;
            z-index: 20;
        }

        #sidebar {
            width: 280px;
            background: #f4e4c1;
            border-left: 4px solid #8b6914;
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 8px rgba(0,0,0,0.1);
        }

        h1 {
            font-size: 24px;
            margin-bottom: 15px;
            color: #654321;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.7);
        }

        .stats-panel {
            background: #ffe8cc;
            border: 2px solid #cd853f;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-weight: bold;
        }

        .stat-label {
            color: #8b4513;
        }

        .stat-value {
            color: #2d5016;
            font-size: 18px;
        }

        .time-display {
            background: #ffd700;
            border: 2px solid #ffa500;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            color: #654321;
        }

        .phase-button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 14px;
            background: linear-gradient(135deg, #1a1a2e 0%, #2d3561 100%);
        }

        .phase-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .buildings-section {
            margin-top: 20px;
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            color: #654321;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .building-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
            font-size: 14px;
        }

        .building-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .building-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .town-hall-btn {
            background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
        }

        .barracks-btn {
            background: linear-gradient(135deg, #696969 0%, #808080 100%);
        }

        .info-box {
            background: #fff8dc;
            border: 2px solid #daa520;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            color: #654321;
        }

        .production-section {
            background: #fff8dc;
            border: 2px solid #daa520;
            border-radius: 6px;
            padding: 12px;
            margin-top: 20px;
        }

        .produce-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #32cd32 0%, #228b22 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 8px;
        }

        .produce-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .produce-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #nightUI {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 10;
            color: #eee;
            font-family: 'Courier New', monospace;
            display: none;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff3366;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            z-index: 5;
            display: none;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #e8dcc8;
        }

        ::-webkit-scrollbar-thumb {
            background: #cd853f;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="dayContainer">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div id="nightContainer">
            <canvas id="nightCanvas"></canvas>
            <canvas id="minimapCanvas"></canvas>
            <div id="nightUI">
                <div>Night Defense Mode</div>
                <div>WASD - Move | Mouse - Look</div>
            </div>
            <div id="crosshair">+</div>
        </div>

        <div id="sidebar">
            <h1>üèòÔ∏è Tiny Village</h1>
            
            <button class="phase-button" id="phaseToggle">Start Night</button>
            
            <div class="time-display">
                <div id="dayDisplay">Day Phase</div>
                <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;" id="timeUntilNight">Time: 0s / 120s</div>
            </div>

            <div class="stats-panel">
                <div class="stat">
                    <span class="stat-label">üë∑ Workers</span>
                    <span class="stat-value" id="workerCount">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">‚öíÔ∏è Warriors</span>
                    <span class="stat-value" id="warriorCount">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">üí∞ Resources</span>
                    <span class="stat-value" id="resourceCount">100</span>
                </div>
                <div class="stat">
                    <span class="stat-label">üë• Population</span>
                    <span class="stat-value" id="popCount">0</span>
                </div>
            </div>

            <div class="buildings-section">
                <div class="section-title">Buildings</div>
                
                <button class="building-btn town-hall-btn" id="townHallBtn">
                    üèõÔ∏è Town Hall
                    <div style="font-size: 11px; opacity: 0.9; margin-top: 3px;">Cost: 50</div>
                </button>
                <div class="info-box">
                    <div style="font-weight: bold; margin-bottom: 5px;">Town Hall</div>
                    <div>Produces workers</div>
                </div>

                <button class="building-btn barracks-btn" id="barracksBtn">
                    üõ°Ô∏è Barracks
                    <div style="font-size: 11px; opacity: 0.9; margin-top: 3px;">Cost: 80</div>
                </button>
                <div class="info-box">
                    <div style="font-weight: bold; margin-bottom: 5px;">Barracks</div>
                    <div>Produces warriors</div>
                </div>
            </div>

            <div id="productionSection" class="production-section" style="display: none;">
                <div style="font-weight: bold; color: #654321; margin-bottom: 10px; font-size: 14px;" id="selectedBuildingName">Building Selected</div>
                <button class="produce-btn" id="produceBtn">Produce Unit</button>
                <button style="width: 100%; padding: 8px; background: #d3d3d3; color: #654321; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 12px;" id="cancelSelectionBtn">Deselect</button>
            </div>
        </div>
    </div>

    <script>
        // FIXED: Calculate canvas size based on actual container dimensions
        const DAY_CANVAS_WIDTH = 1120;
        const DAY_CANVAS_HEIGHT = 900;
        const NIGHT_CANVAS_WIDTH = 1400;
        const NIGHT_CANVAS_HEIGHT = 900;
        
        const dayCanvas = document.getElementById('gameCanvas');
        const dayCtx = dayCanvas.getContext('2d');
        
        // Set canvas to fill its container
        const dayContainer = document.getElementById('dayContainer');
        dayCanvas.width = dayContainer.clientWidth;
        dayCanvas.height = dayContainer.clientHeight;

        const nightCanvas = document.getElementById('nightCanvas');
        const nightCtx = nightCanvas.getContext('2d');
        nightCanvas.width = NIGHT_CANVAS_WIDTH;
        nightCanvas.height = NIGHT_CANVAS_HEIGHT;

        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 200;
        minimapCanvas.height = 200;

        // FIXED: Make grid sizes match the conversion ratio
        // Night cellSize should be proportional to day GRID_SIZE
        const GRID_SIZE = 40;  // Day grid
        const MAZE_CELL_SIZE = 40;  // Night - now matches day for 1:1 conversion
        
        const COLS = Math.floor(DAY_CANVAS_WIDTH / GRID_SIZE);
        const ROWS = Math.floor(DAY_CANVAS_HEIGHT / GRID_SIZE);

        // Building types
        const BUILDING_TYPES = {
            TOWN_HALL: {
                name: 'Town Hall',
                cost: 50,
                width: 2,
                height: 2,
                color: '#8b4513',
                productionType: 'worker',
                productionCost: 20,
                productionAmount: 1
            },
            BARRACKS: {
                name: 'Barracks',
                cost: 80,
                width: 2,
                height: 2,
                color: '#696969',
                productionType: 'warrior',
                productionCost: 30,
                productionAmount: 1
            }
        };

        // ===== CLASSES =====
        class Worker {
            constructor(startX, startY) {
                this.x = startX * GRID_SIZE + GRID_SIZE / 2;
                this.y = startY * GRID_SIZE + GRID_SIZE / 2;
                this.vx = (Math.random() - 0.5) * 1.6;
                this.vy = (Math.random() - 0.5) * 1.6;
                this.speed = 1;
                this.size = 6;
            }

            update() {
                if (Math.random() < 0.03) {
                    this.vx = (Math.random() - 0.5) * 1.6;
                    this.vy = (Math.random() - 0.5) * 1.6;
                }

                let newX = this.x + this.vx * this.speed;
                let newY = this.y + this.vy * this.speed;

                if (newX < 0 || newX > dayCanvas.width) {
                    this.vx *= -1;
                    newX = Math.max(0, Math.min(dayCanvas.width, newX));
                }
                if (newY < 0 || newY > dayCanvas.height) {
                    this.vy *= -1;
                    newY = Math.max(0, Math.min(dayCanvas.height, newY));
                }

                this.x = newX;
                this.y = newY;
            }

            draw() {
                dayCtx.fillStyle = '#8b7355';
                dayCtx.strokeStyle = '#5c4033';
                dayCtx.lineWidth = 2;

                dayCtx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                    const px = this.x + Math.cos(angle) * this.size;
                    const py = this.y + Math.sin(angle) * this.size;
                    if (i === 0) dayCtx.moveTo(px, py);
                    else dayCtx.lineTo(px, py);
                }
                dayCtx.closePath();
                dayCtx.fill();
                dayCtx.stroke();

                dayCtx.fillStyle = '#f4a460';
                dayCtx.beginPath();
                dayCtx.arc(this.x, this.y - this.size - 2, this.size * 0.4, 0, Math.PI * 2);
                dayCtx.fill();
            }
        }

        class Mine {
            constructor(gridX, gridY) {
                this.gridX = gridX;
                this.gridY = gridY;
                this.size = 1.5;
            }

            draw() {
                const centerX = this.gridX * GRID_SIZE;
                const centerY = this.gridY * GRID_SIZE;
                const size = this.size * GRID_SIZE;

                dayCtx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                dayCtx.beginPath();
                dayCtx.arc(centerX + 2, centerY + 2, size + 2, 0, Math.PI * 2);
                dayCtx.fill();

                dayCtx.fillStyle = '#4a4a4a';
                dayCtx.strokeStyle = '#2a2a2a';
                dayCtx.lineWidth = 3;
                
                dayCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3 - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * size;
                    const y = centerY + Math.sin(angle) * size;
                    if (i === 0) dayCtx.moveTo(x, y);
                    else dayCtx.lineTo(x, y);
                }
                dayCtx.closePath();
                dayCtx.fill();
                dayCtx.stroke();

                dayCtx.fillStyle = 'rgba(255, 200, 0, 0.6)';
                dayCtx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3 - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * (size * 0.6);
                    const y = centerY + Math.sin(angle) * (size * 0.6);
                    if (i === 0) dayCtx.moveTo(x, y);
                    else dayCtx.lineTo(x, y);
                }
                dayCtx.closePath();
                dayCtx.fill();

                dayCtx.fillStyle = '#ffff99';
                dayCtx.beginPath();
                dayCtx.arc(centerX, centerY, size * 0.2, 0, Math.PI * 2);
                dayCtx.fill();
            }
        }

        class Building {
            constructor(type, gridX, gridY) {
                this.type = type;
                this.gridX = gridX;
                this.gridY = gridY;
            }

            produce() {
                if (gameState.resources >= this.type.productionCost) {
                    gameState.resources -= this.type.productionCost;
                    
                    if (this.type.productionType === 'worker') {
                        gameState.workers += this.type.productionAmount;
                        for (let i = 0; i < this.type.productionAmount; i++) {
                            gameState.workerList.push(new Worker(this.gridX, this.gridY));
                        }
                    }
                    return true;
                }
                return false;
            }

            isPointInside(gridX, gridY) {
                return gridX >= this.gridX && gridX < this.gridX + this.type.width &&
                       gridY >= this.gridY && gridY < this.gridY + this.type.height;
            }

            draw() {
                const x = this.gridX * GRID_SIZE;
                const y = this.gridY * GRID_SIZE;
                const w = this.type.width * GRID_SIZE;
                const h = this.type.height * GRID_SIZE;
                const isSelected = gameState.selectedBuilding === this;

                dayCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                dayCtx.fillRect(x + 3, y + 3, w, h);

                dayCtx.fillStyle = this.type.color;
                dayCtx.fillRect(x, y, w, h);

                dayCtx.strokeStyle = isSelected ? '#ffd700' : '#5c3d2e';
                dayCtx.lineWidth = isSelected ? 5 : 3;
                dayCtx.strokeRect(x, y, w, h);

                dayCtx.fillStyle = '#a0522d';
                dayCtx.fillRect(x + 5, y + 5, w - 10, 8);
            }

            canPlace(gridX, gridY) {
                if (gridX + this.type.width > COLS || gridY + this.type.height > ROWS) {
                    return false;
                }

                for (const building of gameState.buildings) {
                    if (!(gridX + this.type.width <= building.gridX ||
                          gridX >= building.gridX + building.type.width ||
                          gridY + this.type.height <= building.gridY ||
                          gridY >= building.gridY + building.type.height)) {
                        return false;
                    }
                }

                return true;
            }
        }

        // Sprite class for 3D rendering
        class Sprite {
            constructor(x, y, texture, width = 40, height = 60) {
                this.x = x;
                this.y = y;
                this.texture = texture;
                this.width = width;
                this.height = height;
            }

            getScreenPosition(player, maze) {
                const dx = this.x - player.x;
                const dy = this.y - player.y;
                
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx);
                
                let relativeAngle = angle - player.angle;
                
                while (relativeAngle > Math.PI) relativeAngle -= Math.PI * 2;
                while (relativeAngle < -Math.PI) relativeAngle += Math.PI * 2;
                
                return { dx, dy, dist, angle, relativeAngle };
            }

            isLineOfSightClear(player, maze) {
                const startX = Math.floor(player.x / maze.cellSize);
                const startY = Math.floor(player.y / maze.cellSize);
                const endX = Math.floor(this.x / maze.cellSize);
                const endY = Math.floor(this.y / maze.cellSize);
                
                // Bresenham line algorithm to check walls along the path
                let x = startX;
                let y = startY;
                const dx = Math.abs(endX - startX);
                const dy = Math.abs(endY - startY);
                const stepX = startX < endX ? 1 : -1;
                const stepY = startY < endY ? 1 : -1;
                let err = dx - dy;
                
                while (true) {
                    // Check if current cell has walls
                    if (x >= 0 && x < maze.cols && y >= 0 && y < maze.rows) {
                        const cell = maze.grid[y][x];
                        // If all walls are set, it's a solid obstacle
                        if (cell.walls.top && cell.walls.bottom && cell.walls.left && cell.walls.right) {
                            return false;
                        }
                    } else {
                        return false; // Out of bounds
                    }
                    
                    if (x === endX && y === endY) break;
                    
                    const err2 = 2 * err;
                    if (err2 > -dy) {
                        err -= dy;
                        x += stepX;
                    }
                    if (err2 < dx) {
                        err += dx;
                        y += stepY;
                    }
                }
                
                return true;
            }

            isVisible(player, maze) {
                const pos = this.getScreenPosition(player, maze);
                
                if (Math.abs(pos.relativeAngle) > player.fov / 2) {
                    return false;
                }
                
                if (pos.dist < 0.5) {
                    return false;
                }
                
                // Check line of sight for occlusion
                if (!this.isLineOfSightClear(player, maze)) {
                    return false;
                }
                
                return true;
            }

            render(player, maze, ctx, canvas) {
                if (!this.isVisible(player, maze)) {
                    return;
                }

                const pos = this.getScreenPosition(player, maze);
                const correctedDist = pos.dist * Math.cos(pos.relativeAngle);
                
                if (correctedDist <= 0) return;
                
                const spriteHeight = (maze.cellSize * 300) / correctedDist;
                const spriteWidth = spriteHeight * (this.width / this.height);
                
                const screenCenterX = (canvas.width / 2) + 
                    (pos.relativeAngle / (player.fov / 2)) * (canvas.width / 2);
                
                const pitchOffset = player.pitch * 300;
                const screenY = canvas.height / 2 + pitchOffset;
                
                const spriteLeft = screenCenterX - spriteWidth / 2;
                const spriteRight = screenCenterX + spriteWidth / 2;
                const spriteTop = screenY - spriteHeight / 2;
                const spriteBottom = screenY + spriteHeight / 2;
                
                if (spriteRight < 0 || spriteLeft > canvas.width) {
                    return;
                }
                
                const clampedLeft = Math.max(0, spriteLeft);
                const clampedRight = Math.min(canvas.width, spriteRight);
                
                for (let screenX = clampedLeft; screenX < clampedRight; screenX++) {
                    // Map screen X to ray index for occlusion check
                    const rayIndex = Math.floor((screenX / canvas.width) * player.rayCount);
                    const wallDist = player.wallDistances[rayIndex] || Infinity;
                    
                    // Skip if wall is closer than sprite
                    if (wallDist < correctedDist) {
                        continue;
                    }
                    
                    const spriteX = (screenX - spriteLeft) / spriteWidth;
                    const texX = Math.floor(spriteX * this.texture.width);
                    
                    const clampedTop = Math.max(0, spriteTop);
                    const clampedBottom = Math.min(canvas.height, spriteBottom);
                    
                    const sampleRate = Math.max(1, Math.floor((clampedBottom - clampedTop) / 32));
                    
                    for (let screenYPos = clampedTop; screenYPos < clampedBottom; screenYPos += sampleRate) {
                        const spriteY = (screenYPos - spriteTop) / spriteHeight;
                        const texY = Math.floor(spriteY * this.texture.height);
                        
                        const pixelData = this.getTexturePixel(texX, texY);
                        
                        if (pixelData.a > 128) {
                            let brightness = Math.max(0.3, 1 - correctedDist / 500);
                            
                            ctx.fillStyle = `rgba(${Math.floor(pixelData.r * brightness)}, ${Math.floor(pixelData.g * brightness)}, ${Math.floor(pixelData.b * brightness)}, ${pixelData.a / 255})`;
                            ctx.fillRect(screenX, screenYPos, 1, sampleRate);
                        }
                    }
                }
            }

            getTexturePixel(x, y) {
                x = Math.max(0, Math.min(x, this.texture.width - 1));
                y = Math.max(0, Math.min(y, this.texture.height - 1));
                
                const imageData = this.texture.imageData;
                const index = (Math.floor(y) * this.texture.width + Math.floor(x)) * 4;
                
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }
        }

        // Brick texture
        const brickTextureData = [
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0
        ];

        function createTextureFromData(data) {
            const texCanvas = document.createElement('canvas');
            texCanvas.width = 32;
            texCanvas.height = 32;
            const texCtx = texCanvas.getContext('2d');
            
            const imageData = texCtx.createImageData(32, 32);
            const pixels = imageData.data;
            
            for (let i = 0; i < data.length; i++) {
                const pixelIndex = i * 4;
                const intensity = data[i] * 255;
                
                pixels[pixelIndex] = intensity * 0.7;
                pixels[pixelIndex + 1] = intensity * 0.3;
                pixels[pixelIndex + 2] = intensity * 0.2;
                pixels[pixelIndex + 3] = 255;
            }
            
            texCtx.putImageData(imageData, 0, 0);
            return texCanvas;
        }

        const brickTexture = createTextureFromData(brickTextureData);
        const brickPixelData = brickTexture.getContext('2d').getImageData(0, 0, 32, 32).data;

        // Load worker sprite texture
        let workerTexture = null;

        const workerImg = new Image();
        workerImg.crossOrigin = 'anonymous';
        console.log('Starting to load worker sprite from: assets/worker.png');
        workerImg.src = 'assets/worker.png';
        
        workerImg.onload = () => {
            console.log('Worker image loaded successfully, dimensions:', workerImg.width, 'x', workerImg.height);
            try {
                const canvas = document.createElement('canvas');
                canvas.width = workerImg.width;
                canvas.height = workerImg.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(workerImg, 0, 0);
                
                workerTexture = {
                    width: workerImg.width,
                    height: workerImg.height,
                    imageData: ctx.getImageData(0, 0, workerImg.width, workerImg.height),
                    canvas: canvas
                };
                
                document.getElementById('phaseToggle').disabled = false;
                console.log('Worker texture created successfully');
            } catch (e) {
                console.error('Error creating texture:', e);
            }
        };
        
        workerImg.onerror = (e) => {
            console.error('Failed to load worker sprite:', e);
            console.error('Image URL:', workerImg.src);
            console.error('Image currentSrc:', workerImg.currentSrc);
        };
        
        workerImg.onabort = () => {
            console.error('Worker sprite loading was aborted');
        };
        
        document.getElementById('phaseToggle').disabled = true;
        document.getElementById('phaseToggle').title = 'Loading worker sprite...';

        class Maze {
            constructor(buildingsList, mineGridX, mineGridY) {
                this.cellSize = MAZE_CELL_SIZE;
                this.buildings = buildingsList;
                this.dayGridSize = GRID_SIZE;
                this.mineGridX = mineGridX;
                this.mineGridY = mineGridY;
                
                this.cols = COLS;
                this.rows = ROWS;
                this.grid = [];
                
                this.initializeGrid();
                this.placeBuildings();
                this.placeMine();
            }

            initializeGrid() {
                for (let y = 0; y < this.rows; y++) {
                    this.grid[y] = [];
                    for (let x = 0; x < this.cols; x++) {
                        this.grid[y][x] = {
                            walls: { top: false, right: false, bottom: false, left: false },
                            visited: false
                        };
                    }
                }
            }

            placeBuildings() {
                for (const building of this.buildings) {
                    const startX = building.gridX;
                    const startY = building.gridY;
                    const endX = building.gridX + building.type.width;
                    const endY = building.gridY + building.type.height;
                    
                    for (let y = startY; y < endY; y++) {
                        for (let x = startX; x < endX; x++) {
                            if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                                this.grid[y][x].walls.top = true;
                                this.grid[y][x].walls.right = true;
                                this.grid[y][x].walls.bottom = true;
                                this.grid[y][x].walls.left = true;
                            }
                        }
                    }
                }
            }

            placeMine() {
                const mineX = this.mineGridX;
                const mineY = this.mineGridY;
                
                const radius = 1;
                for (let dx = -radius; dx <= radius; dx++) {
                    for (let dy = -radius; dy <= radius; dy++) {
                        const x = mineX + dx;
                        const y = mineY + dy;
                        
                        if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                            const dist = Math.abs(dx) + Math.abs(dy);
                            if (dist <= radius) {
                                this.grid[y][x].walls.top = true;
                                this.grid[y][x].walls.right = true;
                                this.grid[y][x].walls.bottom = true;
                                this.grid[y][x].walls.left = true;
                            }
                        }
                    }
                }
            }

            getCell(x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                if (cellX < 0 || cellX >= this.cols || cellY < 0 || cellY >= this.rows) {
                    return null;
                }
                return this.grid[cellY][cellX];
            }

            drawMinimap(playerX, playerY) {
                minimapCtx.fillStyle = '#000';
                minimapCtx.fillRect(0, 0, 200, 200);

                const cellSize = Math.min(200 / this.cols, 200 / this.rows);
                minimapCtx.strokeStyle = '#4a90e2';
                minimapCtx.lineWidth = 1;

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const cell = this.grid[y][x];
                        const screenX = x * cellSize;
                        const screenY = y * cellSize;

                        minimapCtx.beginPath();
                        if (cell.walls.top) {
                            minimapCtx.moveTo(screenX, screenY);
                            minimapCtx.lineTo(screenX + cellSize, screenY);
                        }
                        if (cell.walls.right) {
                            minimapCtx.moveTo(screenX + cellSize, screenY);
                            minimapCtx.lineTo(screenX + cellSize, screenY + cellSize);
                        }
                        if (cell.walls.bottom) {
                            minimapCtx.moveTo(screenX, screenY + cellSize);
                            minimapCtx.lineTo(screenX + cellSize, screenY + cellSize);
                        }
                        if (cell.walls.left) {
                            minimapCtx.moveTo(screenX, screenY);
                            minimapCtx.lineTo(screenX, screenY + cellSize);
                        }
                        minimapCtx.stroke();
                    }
                }

                const playerCellX = Math.floor(playerX / this.cellSize);
                const playerCellY = Math.floor(playerY / this.cellSize);
                minimapCtx.fillStyle = '#ff3366';
                minimapCtx.beginPath();
                minimapCtx.arc(playerCellX * cellSize + cellSize / 2, playerCellY * cellSize + cellSize / 2, cellSize / 3, 0, Math.PI * 2);
                minimapCtx.fill();
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.pitch = 0;
                this.moveSpeed = 3;
                this.fov = Math.PI / 3;
                this.rayCount = 240;
                this.stripWidth = Math.ceil(nightCanvas.width / this.rayCount);
                this.wallDistances = new Array(this.rayCount).fill(Infinity);
            }

            move(dx, dy, maze) {
                const newX = this.x + dx;
                const newY = this.y + dy;
                
                if (!this.checkCollision(newX, this.y, maze)) {
                    this.x = newX;
                }
                if (!this.checkCollision(this.x, newY, maze)) {
                    this.y = newY;
                }
            }

            checkCollision(x, y, maze) {
                const cellX = Math.floor(x / maze.cellSize);
                const cellY = Math.floor(y / maze.cellSize);
                
                if (cellX < 0 || cellX >= maze.cols || cellY < 0 || cellY >= maze.rows) {
                    return true;
                }
                
                const cell = maze.grid[cellY][cellX];
                const localX = x % maze.cellSize;
                const localY = y % maze.cellSize;
                const margin = 8;
                
                if (localY < margin && cell.walls.top) return true;
                if (localY > maze.cellSize - margin && cell.walls.bottom) return true;
                if (localX < margin && cell.walls.left) return true;
                if (localX > maze.cellSize - margin && cell.walls.right) return true;
                
                return false;
            }

            castRays(maze) {
                const rays = [];
                
                for (let i = 0; i < this.rayCount; i++) {
                    const rayAngle = this.angle - this.fov / 2 + (this.fov * i / this.rayCount);
                    const ray = this.castRay(rayAngle, maze);
                    rays.push(ray);
                }
                
                return rays;
            }

            castRay(angle, maze) {
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                let dist = 0;
                const step = 0.5;
                const maxDist = 1000;
                let hitWall = false;
                let hitX = 0;
                let hitY = 0;
                
                while (!hitWall && dist < maxDist) {
                    dist += step;
                    const testX = this.x + dx * dist;
                    const testY = this.y + dy * dist;
                    
                    const cellX = Math.floor(testX / maze.cellSize);
                    const cellY = Math.floor(testY / maze.cellSize);
                    
                    if (cellX < 0 || cellX >= maze.cols || cellY < 0 || cellY >= maze.rows) {
                        hitWall = true;
                        break;
                    }
                    
                    const cell = maze.grid[cellY][cellX];
                    const localX = testX % maze.cellSize;
                    const localY = testY % maze.cellSize;
                    
                    if (localY < 1 && cell.walls.top) {
                        hitWall = true;
                        hitX = testX;
                        hitY = testY;
                    } else if (localY > maze.cellSize - 1 && cell.walls.bottom) {
                        hitWall = true;
                        hitX = testX;
                        hitY = testY;
                    } else if (localX < 1 && cell.walls.left) {
                        hitWall = true;
                        hitX = testX;
                        hitY = testY;
                    } else if (localX > maze.cellSize - 1 && cell.walls.right) {
                        hitWall = true;
                        hitX = testX;
                        hitY = testY;
                    }
                }
                
                return { dist, angle, hitX, hitY };
            }

            render(maze) {
                const rays = this.castRays(maze);
                const pitchOffset = this.pitch * 300;
                const horizonY = nightCanvas.height / 2 + pitchOffset;
                
                nightCtx.fillStyle = '#1a1a2e';
                nightCtx.fillRect(0, 0, nightCanvas.width, nightCanvas.height);
                
                nightCtx.fillStyle = '#00ff88';
                nightCtx.font = '12px Courier';
                nightCtx.fillText(`Player: (${Math.floor(this.x)}, ${Math.floor(this.y)})`, 10, 20);
                nightCtx.fillText(`Maze: ${maze.cols}x${maze.rows}`, 10, 35);
                nightCtx.fillText(`Angle: ${(this.angle * 180 / Math.PI).toFixed(0)}¬∞`, 10, 50);
                
                for (let i = 0; i < rays.length; i++) {
                    const ray = rays[i];
                    const correctedDist = ray.dist * Math.cos(ray.angle - this.angle);
                    const wallHeight = (maze.cellSize * 300) / correctedDist;
                    
                    // Store wall distance for occlusion culling
                    this.wallDistances[i] = correctedDist;const wallTop = (nightCanvas.height - wallHeight) / 2 + pitchOffset;
                    const wallBottom = wallTop + wallHeight;
                    
                    const stripX = i * this.stripWidth;
                    
                    let worldPos = ray.hitY;
                    let texX = Math.floor((Math.abs(worldPos) * 2)) % 32;
                    texX = Math.max(0, Math.min(31, texX));
                    
                    let brightness = Math.max(0.2, 1 - correctedDist / 500);
                    
                    const clampedTop = Math.max(0, Math.floor(wallTop));
                    const clampedBottom = Math.min(nightCanvas.height, Math.ceil(wallBottom));
                    const sampleRate = Math.max(1, Math.floor((clampedBottom - clampedTop) / 32));
                    
                    for (let y = clampedTop; y < clampedBottom; y += sampleRate) {
                        let worldHeight = ((y - wallTop) / (wallBottom - wallTop)) * maze.cellSize;
                        let texY = Math.floor((worldHeight * 0.5)) % 32;
                        texY = Math.max(0, Math.min(31, texY));
                        
                        const texIndex = (texY * 32 + texX) * 4;
                        const r = brickPixelData[texIndex] * brightness;
                        const g = brickPixelData[texIndex + 1] * brightness;
                        const b = brickPixelData[texIndex + 2] * brightness;
                        
                        nightCtx.fillStyle = `rgb(${r},${g},${b})`;
                        nightCtx.fillRect(stripX, y, this.stripWidth, sampleRate);
                    }
                }
            }
        }

        // Game state
        const gameState = {
            resources: 100,
            workers: 0,
            warriors: 0,
            workerList: [],
            warriorList: [],
            buildings: [],
            gamePhase: 'day',
            dayStartTime: Date.now(),
            selectedBuilding: null,
            lastResourceGeneration: Date.now(),
            mine: new Mine(
                Math.floor(COLS * 0.5) + Math.floor(Math.random() * Math.floor(COLS * 0.4)),
                Math.floor(ROWS * 0.4) + Math.floor(Math.random() * Math.floor(ROWS * 0.4))
            ),
            isNight: false,
            nightSprites: []
        };

        let placingBuilding = null;
        let previewPos = { x: 0, y: 0 };
        let maze = null;
        let player = null;
        let pointerLocked = false;
        const keys = {};

        // Functions
        function updateProductionUI() {
            const prodSection = document.getElementById('productionSection');
            
            if (gameState.selectedBuilding) {
                prodSection.style.display = 'block';
                const building = gameState.selectedBuilding;
                const unitName = building.type.productionType === 'worker' ? 'Worker' : 'Warrior';
                
                document.getElementById('selectedBuildingName').textContent = `${building.type.name} - Produce ${unitName}`;
                
                const produceBtn = document.getElementById('produceBtn');
                produceBtn.textContent = `Produce ${unitName} (Cost: ${building.type.productionCost})`;
                produceBtn.disabled = gameState.resources < building.type.productionCost;
            } else {
                prodSection.style.display = 'none';
            }
        }

        function updateUI() {
            document.getElementById('workerCount').textContent = gameState.workers;
            document.getElementById('warriorCount').textContent = gameState.warriors;
            document.getElementById('resourceCount').textContent = Math.floor(gameState.resources);
            document.getElementById('popCount').textContent = gameState.workers + gameState.warriors;

            const elapsed = (Date.now() - gameState.dayStartTime) / 1000;
            document.getElementById('timeUntilNight').textContent = `Time: ${elapsed.toFixed(0)}s / 120s`;

            document.getElementById('townHallBtn').disabled = gameState.resources < 50;
            document.getElementById('barracksBtn').disabled = gameState.resources < 80;

            updateProductionUI();
        }

        function generateResources() {
            const now = Date.now();
            const timeSinceLastGeneration = now - gameState.lastResourceGeneration;
            
            if (timeSinceLastGeneration >= 1000) {
                gameState.resources += gameState.workers;
                gameState.lastResourceGeneration = now;
            }
        }

        function startPlacing(buildingType) {
            if (gameState.resources < buildingType.cost) {
                alert('Not enough resources!');
                return;
            }
            placingBuilding = buildingType;
        }

        function drawDay() {
            dayCtx.fillStyle = '#90ee90';
            dayCtx.fillRect(0, 0, dayCanvas.width, dayCanvas.height);

            for (const building of gameState.buildings) {
                building.draw();
            }

            gameState.mine.draw();

            for (const worker of gameState.workerList) {
                worker.draw();
            }

            if (placingBuilding) {
                const testBuilding = new Building(placingBuilding, previewPos.x, previewPos.y);
                const canPlace = testBuilding.canPlace(previewPos.x, previewPos.y);

                dayCtx.fillStyle = canPlace ? 'rgba(144, 238, 144, 0.5)' : 'rgba(255, 100, 100, 0.5)';
                dayCtx.fillRect(previewPos.x * GRID_SIZE, previewPos.y * GRID_SIZE, placingBuilding.width * GRID_SIZE, placingBuilding.height * GRID_SIZE);

                dayCtx.strokeStyle = canPlace ? '#228B22' : '#ff0000';
                dayCtx.lineWidth = 2;
                dayCtx.strokeRect(previewPos.x * GRID_SIZE, previewPos.y * GRID_SIZE, placingBuilding.width * GRID_SIZE, placingBuilding.height * GRID_SIZE);
            }
        }

        function dayGameLoop() {
            if (gameState.isNight) {
                requestAnimationFrame(nightGameLoop);
                return;
            }

            generateResources();
            
            for (const worker of gameState.workerList) {
                worker.update();
            }
            
            updateUI();
            drawDay();
            requestAnimationFrame(dayGameLoop);
        }

        let lastTime = performance.now();

        function nightGameLoop() {
            if (!gameState.isNight) {
                requestAnimationFrame(dayGameLoop);
                return;
            }

            if (!maze || !player) {
                requestAnimationFrame(nightGameLoop);
                return;
            }

            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            const deltaMultiplier = deltaTime / (1000 / 60);

            const moveX = Math.cos(player.angle) * player.moveSpeed * deltaMultiplier;
            const moveY = Math.sin(player.angle) * player.moveSpeed * deltaMultiplier;
            const strafeX = Math.cos(player.angle + Math.PI / 2) * player.moveSpeed * deltaMultiplier;
            const strafeY = Math.sin(player.angle + Math.PI / 2) * player.moveSpeed * deltaMultiplier;

            if (keys['w']) player.move(moveX, moveY, maze);
            if (keys['s']) player.move(-moveX, -moveY, maze);
            if (keys['a']) player.move(-strafeX, -strafeY, maze);
            if (keys['d']) player.move(strafeX, strafeY, maze);

            // Update workers even during night mode
            for (const worker of gameState.workerList) {
                worker.update();
            }

            player.render(maze);

            // Sync sprite positions with worker positions
            for (let i = 0; i < gameState.nightSprites.length; i++) {
                if (i < gameState.workerList.length) {
                    const worker = gameState.workerList[i];
                    gameState.nightSprites[i].x = worker.x;
                    gameState.nightSprites[i].y = worker.y;
                }
            }

            // Render sprites
            for (const sprite of gameState.nightSprites) {
                if (workerTexture) {
                    sprite.render(player, maze, nightCtx, nightCanvas);
                }
            }

            maze.drawMinimap(player.x, player.y);

            requestAnimationFrame(nightGameLoop);
        }

        // Event listeners
        document.getElementById('phaseToggle').addEventListener('click', () => {
            if (!gameState.isNight) {
                gameState.isNight = true;
                document.getElementById('phaseToggle').textContent = 'Return to Day';
                document.getElementById('dayContainer').style.display = 'none';
                document.getElementById('nightContainer').style.display = 'block';
                document.getElementById('nightUI').style.display = 'block';
                document.getElementById('crosshair').style.display = 'block';
                
                maze = new Maze(gameState.buildings, gameState.mine.gridX, gameState.mine.gridY);
                player = new Player(2 * maze.cellSize + maze.cellSize / 2, 2 * maze.cellSize + maze.cellSize / 2);
                
                // Create sprites for workers
                gameState.nightSprites = [];
                for (const worker of gameState.workerList) {
                    const sprite = new Sprite(worker.x, worker.y, workerTexture, 30, 45);
                    gameState.nightSprites.push(sprite);
                }
                
                nightCanvas.requestPointerLock();
                lastTime = performance.now();
            } else {
                gameState.isNight = false;
                document.getElementById('phaseToggle').textContent = 'Start Night';
                document.getElementById('dayContainer').style.display = 'flex';
                document.getElementById('nightContainer').style.display = 'none';
                document.getElementById('nightUI').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
                
                document.exitPointerLock();
            }
        });

        dayCanvas.addEventListener('mousemove', (e) => {
            const rect = dayCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            previewPos = {
                x: Math.floor(x / GRID_SIZE),
                y: Math.floor(y / GRID_SIZE)
            };
        });

        dayCanvas.addEventListener('click', (e) => {
            if (!placingBuilding) {
                const rect = dayCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const gridX = Math.floor(x / GRID_SIZE);
                const gridY = Math.floor(y / GRID_SIZE);

                for (const building of gameState.buildings) {
                    if (building.isPointInside(gridX, gridY)) {
                        gameState.selectedBuilding = building;
                        updateProductionUI();
                        return;
                    }
                }
                gameState.selectedBuilding = null;
                updateProductionUI();
                return;
            }

            const testBuilding = new Building(placingBuilding, previewPos.x, previewPos.y);
            
            if (testBuilding.canPlace(previewPos.x, previewPos.y)) {
                gameState.resources -= placingBuilding.cost;
                gameState.buildings.push(testBuilding);
                placingBuilding = null;
            } else {
                alert('Cannot place building there!');
            }
        });

        document.getElementById('townHallBtn').addEventListener('click', () => {
            startPlacing(BUILDING_TYPES.TOWN_HALL);
        });

        document.getElementById('barracksBtn').addEventListener('click', () => {
            startPlacing(BUILDING_TYPES.BARRACKS);
        });

        document.getElementById('produceBtn').addEventListener('click', () => {
            if (gameState.selectedBuilding) {
                gameState.selectedBuilding.produce();
                updateUI();
            }
        });

        document.getElementById('cancelSelectionBtn').addEventListener('click', () => {
            gameState.selectedBuilding = null;
            updateProductionUI();
        });

        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
        });

        nightCanvas.addEventListener('click', () => {
            nightCanvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === nightCanvas;
        });

        document.addEventListener('mousemove', (e) => {
            if (pointerLocked && player && gameState.isNight) {
                player.angle += e.movementX * 0.0014;
                player.pitch -= e.movementY * 0.0014;
                
                const maxPitch = 1.4;
                player.pitch = Math.max(-maxPitch, Math.min(maxPitch, player.pitch));
            }
        });

        updateUI();
        dayGameLoop();
    </script>
</body>
</html>